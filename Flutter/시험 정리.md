## 플러터가 등장한 이유는?
플러터는 구글이 2017년에 개발한 오픈소스 UI 프레임워크로, ios와 android 앱을 하나의 코드베이스로 개발할 수 있도록 하기위해 등장했다.   
기존의 크로스 플랫폼 프레임워크의 **성능문제, 일관성이 부족한 UI, 복잡한 네이티브 연동 등의 한계** 를 극복하고자 개발되었다.   
특히 고성능 렌더링과 빠른 개발 사이클을 목표로 삼았다.

## 플러터의 핵심 장점은?
- 단일 코드베이스로 iOS, Android, 웹, 데스크탑 앱 개발 가능
- 자체 렌더링 엔진(Skia)을 사용해 운영체제에 의존하지 않고 UI를 직접 그려 일관된 디자인과 성능 제공   
- 빠른 개발 속도: 핫 리로드 기능으로 즉각적인 코드 반영
- 풍부한 위젯 라이브러리: 머티리얼 디자인과 쿠퍼티노 스타일 모두 지원
- 높은 성능: 네이티브 수준의 성능을 제공

## 플러터는 어떤 언어로 개발되는가?
플러터는 Dart언어를 기반으로 개발된다.   
Dart는 구글이 개발한 객체지향 언어로, 간결한 문법과 빠른 실행 속도, 비동기 프로그래밍에 강한 구조를 갖추고 있어 UI 개발에 적합하다.

## 플러터의 주요 특징은?
- 위젯 기반 구조: 모든 UI 요소가 위젯으로 구성되어 있어 재사용성과 커스터마이징이 뛰어남   
- 자체 렌더링 엔진: 플렛폼에 종속적 UI가 아닌 직접 그리는 방식으로 일관된 UI제공   
- 크로스 플랫폼 지원: 모바일뿐 아니라 웹, 데스크탑까지 확장 가능   
- 풍부한 개발 도구: VS Code, Android Studio등 다양한 IDE지원

## 플러터의 핫 리로드 기능이란?
Hot Reload는 플러터의 대표적인 개발 기능으로, 앱을 다시 실행하지 않고도 코드 변경 사항을 즉시 반영할 수 있게 한다. 이를 통해 UI수정이나 기능 테스트를 빠르게 반복할 수 있어 개발 생산성이 크게 향상된다.   
앱의 상태를 유지한 채 UI만 갱신되므로 디버깅에도 유용하다.

## Flutter SDK 설치 시 PATh 설정이 필요한 이유
터미널이나 명령 프롬프트에서 flutter 명령어를 어디서든 실행할 수 있도록 하기 위해서   
운영체제가 flutter 명령을 인식하고 실행할 수 있도록 SDK의 실행 파일 경로를 알려주는 과정

## VS Code에서 Flutter 개발에 가장 필수적인 확장
- Flutter 확장: Flutter 프로젝트 생성, 실행, 디버깅, 위젯 미리보기 등 다양한 기능을 제공   
- Dart 확장: Flutter의 핵심 언어인 Dart의 코드 작성, 자동 완성, 오류 탐지 등을 지원   

## flutter doctor 명령의 역할
**Flutter 개발 환경이 제대로 구성되었는지 점검하는 도구**   
Flutter SDK, Dart SDk, Android Studio, VS Code, 디바이스 연결 상태등 각 구성 요소의 설치 여부와 문제점을 확인할 수 있습니다.

## IDE 설정에서 단축키를 활용하는 이유
개발 효율성, 생산성   

## Flutter 프로젝트에서 필요한 패키지를 추가할 때 사용하는 파일
**pubspec.yaml**   
외부 패키지를 추가하거나 의존성을 관리할 때 사용하는 파일이며 이 파일안에 패키지 이름과 버전을 명시하고 flutter pub get 명령을 통해 해당 패키지를 프로젝트에 설지할 수 있다.   

## final과 const의 차이
- final: 런타임 시점에 값이 결정되며, 한 번 할당되면 변경할 수 없음   
- const: 컴파일 시점에 값이 결정되며, 완전히 불변이다.(객체 자체도 불변)

## 다트 기본 자료형
- int, double   
- String   
- bool    
- list, Map   
- var   
- dynamic   

## late의 역할
late는 변수를 **나중에 초기화** 하겠다는 의미.   
선언 시 값을 할당하지 않아도 된다. 단, 사용전에 반드시 초기화되어야 한다.   

## ? 연산자의 의미
null이 될 수 있는 변수를 만들 때 사용  

## 변수를 한 번만 할당하고 변경할 수 없게 만드는 키워드
final, const   

## null값을 허용하는 변수 타입은?
?

## 다트 함수 선언
void main() {}
String name() {return "name";}

## 반복문 작성
for(int i =0; i<arr.length; i++){   
    print(i);   
}   

int i=0;
while(i<arr.length()){   
    print(i);   
    i++;   
}
  
## OOP의 핵심 개념
객체 지향 프로그램은 프로그램을 객체 단위로 나누어 설계하는 패러다임.   
객체 간의 상호작용으로 프로그램이 구성된다.  
   
OPP의 주요 특징:   
- 캡슐화 : 객체의 내부 데이터를 외부에서 직접 접근하지 못 하도록 보호하고 매서드롤 통해 접근을 제한함.   
- 추상화 : 복잡한 내부 구현을 숨기고 필요한 기능만 외부에 제공하여 설계의 유연성을 높임.   
- 상속 : 부모 클래스의 속성과 기능을 자식 클래스가 물려받아 코드 재사용성과 유지보수를 향상시킴   
- 다형성 : 하나의 인터페이스로 여러 형태의 객체를 처리할 수 있어 코드의 유연성과 확장성이 높아짐   

## 플러터 앱의 가장 기본 단위는?
Flutter에서 모든 UI요소는 위젯으로 구성된다.

## StatelessWidget의 특징은?
StatelessWidget은 상태가 없는 위젯으로, 내부 상태가 변경되지 않으며 UI도 고정된다.   
(변경이 필요한 경우 새 위젯을 생성해야 한다.)

## StatefulWidget에서 상태를 관리하는 클래스 예시
class MyWidget extends StatefulWidget {   
    const MyWidget({key? key}) : super(key:key);   
   
    @override   
    state<MyWidget> reateState() => _MyWidgetState();   
}   

class _MyWidgetState extends State<MyWidget> {   
    int counter = 0;   

    @override   
    Widget build(BuildContext context){   
        return Text('Counter: $counter');   
    }   
}   

## 위젯 트리의 루트에 위치한 것은?
일반적으로 MaterialApp 또는 CupertinoApp이 루트에 위치한다.   
이들은 앱의 전체의 테마, 라우팅, 네비게이션 등을 관리한다. 

## Column 위젯과 Row 위젯의 정렬 방향
Column : 세로   
Row : 가로

## AnimatedContainer의 기능
Container의 속성 변화(크기, 색상, 테두리 등)를 애니메이션 효과로 부드럽게 보여주는 위젯

## Navigator.push()의 역할
새 화면(Route)을 현재 화면 위에 쌓아 올리는 기능을 한다.   
즉, 페이지 이동 시 사용되며, 이전 화면은 스택에 남아 있어 Navigator.pop으로 돌아갈 수 있다.   

## setState() 호출의 올바른 목적
StatefulWidget의 상태를 변경하고 UI를 다시 빌드하기 위해 호출한다.   
상태가 변경되었음을 Flutter에게 알리는 역할을 하며, 변경된 상태에 따라 UI가 다시 그려진다.